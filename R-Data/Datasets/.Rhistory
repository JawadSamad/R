pl_corruption <- ggplot(df_overall.scores.2018, aes(x=Perceptions.of.corruption, y=Score, color=Country.or.region)) + geom_point(size=3, shape=1, show.legend = FALSE) + geom_smooth(aes(group=1))
print(pl_corruption)
help(geam_smooth)
??geom_smooth
pl_corruption <- ggplot(df_overall.scores.2018, aes(x=Perceptions.of.corruption, y=Score, color=Country.or.region)) + geom_point(size=3, shape=1, show.legend = FALSE) + geom_smooth(aes(group=1), show.legend = FALSE)
print(pl_corruption)
pl_corruption <- ggplot(df_overall.scores.2018, aes(x=Perceptions.of.corruption, y=Score, color=Country.or.region)) + geom_point(size=3, shape=1, show.legend = FALSE) + geom_smooth(aes(group=1), show.legend = FALSE, method = "lm", formula = y~log(x), se=F, color="Red")
print(pl_corruption)
pl_corruption <- ggplot(df_overall.scores.2018, aes(x=Perceptions.of.corruption, y=Score, color=Country.or.region)) + geom_point(size=3, shape=1, show.legend = FALSE) + geom_smooth(aes(group=1), show.legend = FALSE, method = "lm", formula = y~log(x), se=F, color="Red")
print(pl_corruption)
pl_corruption <- ggplot(df_overall.scores.2018, aes(x=Perceptions.of.corruption, y=Score, color=Country.or.region)) +
geom_point(size=3, shape=1, show.legend = FALSE) + geom_smooth(aes(group=1), method = "lm", formula = y~log(x), se=F, color="Red",show.legend = FALSE, )
pl_corruption <- ggplot(df_overall.scores.2018, aes(x=Perceptions.of.corruption, y=Score, color=Country.or.region)) + geom_point(size=3, shape=1, show.legend = FALSE) + geom_smooth(aes(group=1), method = "lm", formula = y~log(x), se=F, color="Red",show.legend = FALSE, )
print(pl_corruption)
o
pl_corruption <- ggplot(df_overall.scores.2018, aes(x=Perceptions.of.corruption, y=Score, color=Country.or.region)) + geom_point(size=3, shape=1, show.legend = FALSE) + geom_smooth(aes(group=1), method = "lm", se=F, color="Red",show.legend = FALSE, )
print(pl_corruption)
pl_corruption <- ggplot(df_overall.scores.2018, aes(x=Perceptions.of.corruption, y=Score, color=Country.or.region)) + geom_point(size=3, shape=1, show.legend = FALSE) + geom_smooth(aes(group=1), method = "lm", se=F, color="Red",show.legend = FALSE)
print(pl_corruption)
pl_corruption <- ggplot(df_overall.scores.2018, aes(x=Perceptions.of.corruption, y=Score, color=Country.or.region)) + geom_point(size=3, shape=1, show.legend = FALSE) + geom_smooth(aes(group=1), method = "lm", se=F, color="Red",show.legend = FALSE, formula = x~log(y))
print(pl_corruption)
pl_corruption <- ggplot(df_overall.scores.2018, aes(x=Perceptions.of.corruption, y=Score, color=Country.or.region)) + geom_point(size=3, shape=1, show.legend = FALSE) + geom_smooth(aes(group=1), method = "lm", se=F, color="Red",show.legend = FALSE, formula = y~log(x))
print(pl_corruption)
pl_corruption <- ggplot(df_overall.scores.2018, aes(x=Perceptions.of.corruption, y=Score, color=Country.or.region)) + geom_point(size=3, shape=1, show.legend = FALSE) + geom_smooth(aes(group=1), method = "lm", se=F, color="Red",show.legend = FALSE, formula = y~x)
print(pl_corruption)
pl_corruption <- ggplot(df_overall.scores.2018, aes(x=Perceptions.of.corruption, y=Score, color=Country.or.region)) + geom_point(size=3, shape=1, show.legend = FALSE) + geom_smooth(aes(group=1), se=F, color="Red",show.legend = FALSE, formula = y~x)
print(pl_corruption)
method = "lm",
pl_corruption <- ggplot(df_overall.scores.2018, aes(x=Perceptions.of.corruption, y=Score, color=Country.or.region)) + geom_point(size=3, shape=1, show.legend = FALSE) + geom_smooth(aes(group=1), method = "lm", se=F, color="Red",show.legend = FALSE, formula = y~x)
print(pl_corruption)
pl_corruption <- ggplot(df_overall.scores.2018, aes(x=Perceptions.of.corruption, y=Score, color=Country.or.region)) + geom_point(size=3, shape=1, show.legend = FALSE) + geom_smooth(aes(group=1), method = "glm", se=F, color="Red",show.legend = FALSE, formula = y~x)
print(pl_corruption)
pl_corruption <- ggplot(df_overall.scores.2018, aes(x=Perceptions.of.corruption, y=Score, color=Country.or.region)) + geom_point(size=3, shape=1, show.legend = FALSE) + geom_smooth(aes(group=1), se=F, color="Red",show.legend = FALSE, formula = y~x)
#output
z.scores.2018
print(pl_corruption)
pl_corruptions <- pl_corruption + geom_text(aes(label=Country.or.region))
pl_corruptions
pl_corruptions
pl_corruptions <- pl_corruption + geom_text(aes(label=Country.or.region), show.legend = FALSE)
pl_corruptions
pl_corruption <- ggplot(df_overall.scores.2018, aes(x=Score, y=Perceptions.of.corruption, color=Country.or.region)) + geom_point(size=3, shape=1, show.legend = FALSE) + geom_smooth(aes(group=1), se=F, color="Red",show.legend = FALSE, formula = y~x)
pl_corruptions
pl_corruptions <- pl_corruption + geom_text(aes(label=Country.or.region), show.legend = FALSE)
pl_corruptions
source('~/R/R-project/UdemyCourse/Datasets/Test.R')
pl_corruptions
pointsToLabel <- c("Russia", "Venezuela", "Iraq", "Myanmar", "Sudan",
"Afghanistan", "Qatar", "Greece", "Argentina", "Brazil",
"Malta", "Italy", "China", "South Korea", "Spain",
"Botswana", "Indonesia", "Bhutan", "Colombia", "France",
"United States", "Germany", "Iran", "Luxembourg", "Norway", "Japan",
"New Zealand", "Singapore")
pl_corruption <- ggplot(df_overall.scores.2018, aes(x=Score, y=Perceptions.of.corruption, color=Country.or.region)) + geom_point(size=3, shape=1, show.legend = FALSE) + geom_smooth(aes(group=1), se=F, color="Red",show.legend = FALSE, formula = y~x)
pl_corruptions <- pl_corruption + geom_text(aes(label=Country.or.region), show.legend = FALSE, data = subset(df_overall.scores.2018, Country.or.region %in% pointsToLabel),check_overlap = TRUE)
pl_corruptions
pointsToLabel <- c("Russia", "Venezuela", "Iraq", "Myanmar", "Sudan",
"Afghanistan", "Qatar", "Greece", "Argentina", "Brazil",
"Malta", "Italy", "China", "South Korea", "Spain",
"Botswana", "Indonesia", "Bhutan", "Colombia", "France",
"United States", "Germany", "Iran", "Luxembourg", "Norway", "Japan",
"New Zealand", "Singapore","Rwanda")
pl_corruption <- ggplot(df_overall.scores.2018, aes(x=Score, y=Perceptions.of.corruption, color=Country.or.region)) + geom_point(size=3, shape=1, show.legend = FALSE) + geom_smooth(aes(group=1), se=F, color="Red",show.legend = FALSE, formula = y~x)
pl_corruptions <- pl_corruption + geom_text(aes(label=Country.or.region), show.legend = FALSE, data = subset(df_overall.scores.2018, Country.or.region %in% pointsToLabel),check_overlap = TRUE)
pl_corruptions
library(ggthemes)
install.packages('ggthemes')
library(ggthemes)
pl_corruptions + theme_economist_white()
pl_corruptions <- pl_corruption + geom_text(aes(label=Country.or.region, color="black"), show.legend = FALSE, data = subset(df_overall.scores.2018, Country.or.region %in% pointsToLabel),check_overlap = TRUE)
pl_corruptions + theme_economist_white()
pl_corruptions <- pl_corruption + geom_text(aes(label=Country.or.region), show.legend = FALSE, data = subset(df_overall.scores.2018, Country.or.region %in% pointsToLabel),check_overlap = TRUE)
pl_corruptions + theme_economist_white()
print(pl_histrogram + geom_histogram(binwidth = 0.1, color="Red", fill="Pink", alpha=0.4))
pl_barplot + geom_bin2d() + scale_fill_gradient(high = "red", low = "green")
pl_corruption <- ggplot(df_overall.scores.2018, aes(x=GDP.per.capita, y=Perceptions.of.corruption, color=Country.or.region)) + geom_point(size=3, shape=1, show.legend = FALSE) + geom_smooth(aes(group=1), se=F, color="Red",show.legend = FALSE, formula = y~x)
pl_corruptions <- pl_corruption + geom_text(aes(label=Country.or.region), show.legend = FALSE, data = subset(df_overall.scores.2018, Country.or.region %in% pointsToLabel),check_overlap = TRUE)
pl_corruptions + theme_economist_white()
pl_corruption <- ggplot(df_overall.scores.2018, aes(x=Perceptions.of.corruption, y=GDP.per.capita, color=Country.or.region)) + geom_point(size=3, shape=1, show.legend = FALSE) + geom_smooth(aes(group=1), se=F, color="Red",show.legend = FALSE, formula = y~x)
pl_corruptions <- pl_corruption + geom_text(aes(label=Country.or.region), show.legend = FALSE, data = subset(df_overall.scores.2018, Country.or.region %in% pointsToLabel),check_overlap = TRUE)
pl_corruptions + theme_economist_white()
pl_corruption <- ggplot(df_overall.scores.2018, aes(x=GDP.per.capita, y=Perceptions.of.corruption, color=Country.or.region)) + geom_point(size=3, shape=1, show.legend = FALSE) + geom_smooth(aes(group=1), se=F, color="Red",show.legend = FALSE, formula = y~x)
pl_corruptions <- pl_corruption + geom_text(aes(label=Country.or.region), show.legend = FALSE, data = subset(df_overall.scores.2018, Country.or.region %in% pointsToLabel),check_overlap = TRUE)
pl_corruptions + theme_economist_white()
#Created a points to label vector which I will use for corruption plot
pointsToLabel <- c("Russia", "Venezuela", "Iraq", "Myanmar", "Sudan",
"Afghanistan", "Qatar", "Greece", "Argentina", "Brazil",
"Malta", "Italy", "China", "South Korea", "Spain",
"Botswana", "Indonesia", "Bhutan", "Colombia", "France",
"United States", "Germany", "Iran", "Luxembourg", "Norway", "Japan",
"New Zealand", "Singapore","Rwanda", "United Arab Emirates")
#Created a plot with circles representing the GDP of a country versus the perception of corruption
pl_corruption <- ggplot(df_overall.scores.2018, aes(x=GDP.per.capita, y=Perceptions.of.corruption, color=Country.or.region)) + geom_point(size=3, shape=1, show.legend = FALSE) + geom_smooth(aes(group=1), se=F, color="Red",show.legend = FALSE, formula = y~x)
#Used my pointsToLabel vector to indicate the specified countries which I wanted to show and not all of them
pl_corruptions <- pl_corruption + geom_text(aes(label=Country.or.region), show.legend = FALSE, data = subset(df_overall.scores.2018, Country.or.region %in% pointsToLabel),check_overlap = TRUE)
#Added in a theme for the presentation.
pl_corruptions + theme_economist_white()
#Added in a theme for the presentation.
pl_corruptions
#Added in a theme for the presentation.
pl_corruptions + theme_economist_white()
#Created a scatterplot which outputs the overall scores and the GDP.
pl <- ggplot(data = df_overall.scores.2019, aes(x=GDP.per.capita, y=Score))
pl + geom_point(alpha=0.6, aes(size=Perceptions.of.corruption, color=Perceptions.of.corruption)) + scale_color_gradient(low="Blue", high = "Red")
#Created a histrogram which outputs the scores of the dataset
pl_histrogram <- ggplot(data = df_overall.scores.2019, aes(x=Score))
print(pl_histrogram + geom_histogram(binwidth = 0.1, color="Red", fill="Pink", alpha=0.4))
#Created a barplot, functions as a heatmap to see if the life expectancy is better if a country has a higher GDP
pl_barplot <- ggplot(df_overall.scores.2019, aes(x=Healthy.life.expectancy, y=GDP.per.capita))
pl_barplot + geom_bin2d() + scale_fill_gradient(high = "red", low = "green")
#Created a points to label vector which I will use for corruption plot
pointsToLabel <- c("Russia", "Venezuela", "Iraq", "Myanmar", "Sudan",
"Afghanistan", "Qatar", "Greece", "Argentina", "Brazil",
"Malta", "Italy", "China", "South Korea", "Spain",
"Botswana", "Indonesia", "Bhutan", "Colombia", "France",
"United States", "Germany", "Iran", "Luxembourg", "Norway", "Japan",
"New Zealand", "Singapore","Rwanda", "United Arab Emirates")
#Created a plot with circles representing the GDP of a country versus the perception of corruption
pl_corruption <- ggplot(df_overall.scores.2019, aes(x=GDP.per.capita, y=Perceptions.of.corruption, color=Country.or.region)) + geom_point(size=3, shape=1, show.legend = FALSE) + geom_smooth(aes(group=1), se=F, color="Red",show.legend = FALSE, formula = y~x)
#Used my pointsToLabel vector to indicate the specified countries which I wanted to show and not all of them
pl_corruptions <- pl_corruption + geom_text(aes(label=Country.or.region), show.legend = FALSE, data = subset(df_overall.scores.2019, Country.or.region %in% pointsToLabel),check_overlap = TRUE)
#Added in a theme for the presentation.
pl_corruptions + theme_economist_white()
#2018
#Created a scatterplot which outputs the overall scores and the GDP.
pl_2018 <- ggplot(data = df_overall.scores.2018, aes(x=GDP.per.capita, y=Score))
pl_2018 + geom_point(alpha=0.6, aes(size=Perceptions.of.corruption, color=Perceptions.of.corruption)) + scale_color_gradient(low="Blue", high = "Red")
#Created a histrogram which outputs the scores of the dataset
pl_histrogram_2018 <- ggplot(data = df_overall.scores.2018, aes(x=Score))
print(pl_histrogram_2018 + geom_histogram(binwidth = 0.1, color="Red", fill="Pink", alpha=0.4))
#Created a barplot, functions as a heatmap to see if the life expectancy is better if a country has a higher GDP
pl_barplot_2018 <- ggplot(df_overall.scores.2018, aes(x=Healthy.life.expectancy, y=GDP.per.capita))
pl_barplot_2018 + geom_bin2d() + scale_fill_gradient(high = "red", low = "green")
#Created a points to label vector which I will use for corruption plot
pointsToLabel <- c("Russia", "Venezuela", "Iraq", "Myanmar", "Sudan",
"Afghanistan", "Qatar", "Greece", "Argentina", "Brazil",
"Malta", "Italy", "China", "South Korea", "Spain",
"Botswana", "Indonesia", "Bhutan", "Colombia", "France",
"United States", "Germany", "Iran", "Luxembourg", "Norway", "Japan",
"New Zealand", "Singapore","Rwanda", "United Arab Emirates")
#Created a plot with circles representing the GDP of a country versus the perception of corruption
pl_corruption_2018 <- ggplot(df_overall.scores.2018, aes(x=GDP.per.capita, y=Perceptions.of.corruption, color=Country.or.region)) + geom_point(size=3, shape=1, show.legend = FALSE) + geom_smooth(aes(group=1), se=F, color="Red",show.legend = FALSE, formula = y~x)
#Used my pointsToLabel vector to indicate the specified countries which I wanted to show and not all of them
pl_corruptions_2018 <- pl_corruption_2018 + geom_text(aes(label=Country.or.region), show.legend = FALSE, data = subset(df_overall.scores.2018, Country.or.region %in% pointsToLabel),check_overlap = TRUE)
#Added in a theme for the presentation.
pl_corruptions_2018 + theme_economist_white()
#2019
#Created a scatterplot which outputs the overall scores and the GDP.
pl_2019 <- ggplot(data = df_overall.scores.2019, aes(x=GDP.per.capita, y=Score))
pl_2019 + geom_point(alpha=0.6, aes(size=Perceptions.of.corruption, color=Perceptions.of.corruption)) + scale_color_gradient(low="Blue", high = "Red")
#Created a histrogram which outputs the scores of the dataset
pl_histrogram_2019 <- ggplot(data = df_overall.scores.2019, aes(x=Score))
print(pl_histrogram_2019 + geom_histogram(binwidth = 0.1, color="Red", fill="Pink", alpha=0.4))
#Created a barplot, functions as a heatmap to see if the life expectancy is better if a country has a higher GDP
pl_barplot_2019 <- ggplot(df_overall.scores.2019, aes(x=Healthy.life.expectancy, y=GDP.per.capita))
pl_barplot_2019 + geom_bin2d() + scale_fill_gradient(high = "red", low = "green")
#Created a points to label vector which I will use for corruption plot
pointsToLabel <- c("Russia", "Venezuela", "Iraq", "Myanmar", "Sudan",
"Afghanistan", "Qatar", "Greece", "Argentina", "Brazil",
"Malta", "Italy", "China", "South Korea", "Spain",
"Botswana", "Indonesia", "Bhutan", "Colombia", "France",
"United States", "Germany", "Iran", "Luxembourg", "Norway", "Japan",
"New Zealand", "Singapore","Rwanda", "United Arab Emirates")
#Created a plot with circles representing the GDP of a country versus the perception of corruption
pl_corruption_2019 <- ggplot(df_overall.scores.2019, aes(x=GDP.per.capita, y=Perceptions.of.corruption, color=Country.or.region)) + geom_point(size=3, shape=1, show.legend = FALSE) + geom_smooth(aes(group=1), se=F, color="Red",show.legend = FALSE, formula = y~x)
#Used my pointsToLabel vector to indicate the specified countries which I wanted to show and not all of them
pl_corruptions_2019 <- pl_corruption_2019 + geom_text(aes(label=Country.or.region), show.legend = FALSE, data = subset(df_overall.scores.2019, Country.or.region %in% pointsToLabel),check_overlap = TRUE)
#Added in a theme for the presentation.
pl_corruptions_2019 + theme_economist_white()
rm(pl_barplot. pl_corruption, pl_corruptions, pl_histrogram, pl_Histrogram)
rm(pl_barplot. pl_corruption, pl_corruptions, pl_histrogram, pl_Histrogram)
rm(pl_barplot, pl_corruption, pl_corruptions, pl_histrogram, pl_Histrogram)
rm(pl)
View(df_2018)
View(df_arrangedGdpAndLuck2018)
#Selecting specific columns just to show only those values
select(df_arrangedGdpAndLuck2019, Country.or.region, Score, GDP.per.capita, Healthy.life.expectancy)
#Calculating the z scores of the scores in 2019
z.scores.2019 <- (df_overall.scores.2019$Score - mean2019) / sd2019
#output
z.scores.2019
#--------------------------------------------------------------------------------------------#
#2018
#Created a scatterplot which outputs the overall scores and the GDP.
pl_2018 <- ggplot(data = df_overall.scores.2018, aes(x=GDP.per.capita, y=Score))
pl_2018 + geom_point(alpha=0.6, aes(size=Perceptions.of.corruption, color=Perceptions.of.corruption)) + scale_color_gradient(low="Blue", high = "Red")
pl_2019 + geom_point(alpha=0.6, aes(size=Perceptions.of.corruption, color=Perceptions.of.corruption)) + scale_color_gradient(low="Blue", high = "Red")
print(pl_histrogram_2018 + geom_histogram(binwidth = 0.1, color="Red", fill="Pink", alpha=0.4))
print(pl_histrogram_2019 + geom_histogram(binwidth = 0.1, color="Red", fill="Pink", alpha=0.4))
print(pl_histrogram_2018 + geom_histogram(binwidth = 0.1, color="Red", fill="Pink", alpha=0.4))
print(pl_histrogram_2019 + geom_histogram(binwidth = 0.1, color="Red", fill="Pink", alpha=0.4))
pl_2018 + geom_point(alpha=0.6, aes(size=Perceptions.of.corruption, color=Perceptions.of.corruption)) + scale_color_gradient(low="Blue", high = "Red")
pl_2019 + geom_point(alpha=0.6, aes(size=Perceptions.of.corruption, color=Perceptions.of.corruption)) + scale_color_gradient(low="Blue", high = "Red")
pl_barplot_2019 + geom_bin2d() + scale_fill_gradient(high = "red", low = "green")
pl_barplot_2018 + geom_bin2d() + scale_fill_gradient(high = "red", low = "green")
pl_barplot_2018 + geom_bin2d() + scale_fill_gradient(high = "red", low = "green")
pl_barplot_2019 + geom_bin2d() + scale_fill_gradient(high = "red", low = "green")
pl_barplot_2019 + geom_bin2d() + scale_fill_gradient(high = "red", low = "green")
#Added in a theme for the presentation.
pl_corruptions_2018 + theme_economist_white()
#Created a plot with circles representing the GDP of a country versus the perception of corruption
pl_corruption_2018 <- ggplot(df_overall.scores.2018, aes(x=GDP.per.capita, y=Perceptions.of.corruption, color=Country.or.region)) + geom_point(size=3, shape=1, show.legend = FALSE) + geom_smooth(aes(group=1), method = "lm", se=F, color="Red",show.legend = FALSE, formula = y~x)
#Used my pointsToLabel vector to indicate the specified countries which I wanted to show and not all of them
pl_corruptions_2018 <- pl_corruption_2018 + geom_text(aes(label=Country.or.region), show.legend = FALSE, data = subset(df_overall.scores.2018, Country.or.region %in% pointsToLabel),check_overlap = TRUE)
#Added in a theme for the presentation.
pl_corruptions_2018 + theme_economist_white()
loess??
sad
help("loess")
#Created a plot with circles representing the GDP of a country versus the perception of corruption
pl_corruption_2018 <- ggplot(df_overall.scores.2018, aes(x=GDP.per.capita, y=Perceptions.of.corruption, color=Country.or.region)) + geom_point(size=3, shape=1, show.legend = FALSE) + geom_smooth(aes(group=1), se=F, color="Red",show.legend = FALSE, formula = y~x)
#Used my pointsToLabel vector to indicate the specified countries which I wanted to show and not all of them
pl_corruptions_2018 <- pl_corruption_2018 + geom_text(aes(label=Country.or.region), show.legend = FALSE, data = subset(df_overall.scores.2018, Country.or.region %in% pointsToLabel),check_overlap = TRUE)
#Added in a theme for the presentation.
pl_corruptions_2018 + theme_economist_white()
#Created a plot with circles representing the GDP of a country versus the perception of corruption
pl_corruption_2018 <- ggplot(df_overall.scores.2018, aes(x=GDP.per.capita, y=Perceptions.of.corruption, color=Country.or.region)) + geom_point(size=3, shape=1, show.legend = FALSE) + geom_smooth(aes(group=1), se=F, color="Red",show.legend = FALSE, formula = y~log(x))
#Used my pointsToLabel vector to indicate the specified countries which I wanted to show and not all of them
pl_corruptions_2018 <- pl_corruption_2018 + geom_text(aes(label=Country.or.region), show.legend = FALSE, data = subset(df_overall.scores.2018, Country.or.region %in% pointsToLabel),check_overlap = TRUE)
#Added in a theme for the presentation.
pl_corruptions_2018 + theme_economist_white()
#Created a plot with circles representing the GDP of a country versus the perception of corruption
pl_corruption_2018 <- ggplot(df_overall.scores.2018, aes(x=GDP.per.capita, y=Perceptions.of.corruption, color=Country.or.region)) + geom_point(size=3, shape=1, show.legend = FALSE) + geom_smooth(aes(group=1), se=F, color="Red",show.legend = FALSE, formula = y~x)
#Used my pointsToLabel vector to indicate the specified countries which I wanted to show and not all of them
pl_corruptions_2018 <- pl_corruption_2018 + geom_text(aes(label=Country.or.region), show.legend = FALSE, data = subset(df_overall.scores.2018, Country.or.region %in% pointsToLabel),check_overlap = TRUE)
#Added in a theme for the presentation.
pl_corruptions_2018 + theme_economist_white()
#Added in a theme for the presentation.
pl_corruptions_2019 + theme_economist_white()
str(df_2019)
#Shows the correlation between the numeric values
num.cols <- sapply(df_2018, is.numeric)
#Filtering the data
cor.data <- cor(df_2018[, num.cols])
print(cor.data)
rm(num.cols)
rm(cor.data)
print(col.data)
num.cols <- sapply(df_overall.scores.2018, is.numeric)
#Filtering the data
col.data <- cor(df_overall.scores.2018[,num.cols])
print(col.data)
install.packages("corrplot")
#--------------------------------------------------------------------------------------------#
#2018 - Machine learning
#Figuring out which columns has a correlation with eachother
#Variable created which only subtracts the numeric values(columns) of the dataset
library(corrplot)
#2018 - Machine learning
#Figuring out which columns has a correlation with eachother
#Variable created which only subtracts the numeric values(columns) of the dataset
library(corrplot)
num.cols <- sapply(df_overall.scores.2018, is.numeric)
#Filtering the data
col.data <- cor(df_overall.scores.2018[,num.cols])
print(col.data)
print(corrplot(col.data, method = "color"))
print(corrplot(col.data, method = "color", type = "lower"))
print(corrplot(col.data, method = "color", tl.cex = 0.1))
print(corrplot(col.data, method = "color", tl.cex = 0.3))
print(corrplot(col.data, method = "color", tl.cex = 0.5))
print(corrplot(col.data, method = "color", tl.cex = 0.8))
print(corrplot(col.data, method = "color", tl.cex = 0.4))
print(corrplot(col.data, method = "color", tl.cex = 0.5))
print(corrplot(col.data, method = "color", tl.cex = 0.6))
install.packages("corrgram")
#--------------------------------------------------------------------------------------------#
#2018 - Machine learning
#Figuring out which columns has a correlation with eachother
#Variable created which only subtracts the numeric values(columns) of the dataset
library(corrgram)
corrgram(df_overall.scores.2018)
help("corrgram")
detach("package:corrgram", unload = TRUE)
detach("package:corrplot", unload = TRUE)
remove.packages("corrgram", lib="~/R/win-library/4.0")
remove.packages("corrplot", lib="~/R/win-library/4.0")
print(col.data)
install.packages("caTools")
install.packages("caTools")
clusterHappiness <- kmeans(df_overall.scores.2018[,4:9], 5, nstart = 20)
print(clusterHappiness)
table(clusterHappiness$cluster, df_overall.scores.2018$Score)
table(clusterHappiness$cluster, df_overall.scores.2018$Overall.scores)
table(clusterHappiness$cluster, df_overall.scores.2018$Overall.rank)
table(clusterHappiness$cluster, df_overall.scores.2018$Country.or.region)
table(clusterHappiness$cluster, df_overall.scores.2018$Score)
library(cluster)
clusplot(df_overall.scores.2018, clusterHappiness$cluster, color = T, shade = T, labels = 0, lines = 0)
clusplot(df_overall.scores.2018, clusterHappiness$cluster, color = T, shade = T, labels = 0, lines = 0)
install.packages("neuralnet")
maxs <- apply(df_overall.scores.2018, 2, max)
maxs
maxs
mins
mins <- apply(df_overall.scores.2018, 2, min)
mins
#Normalizing the data
scaled_data <- scale(df_overall.scores.2018, center = mins, scale = maxs - mins)
#Normalizing the data
scaled_data <- scale(df_overall.scores.2018, center = mins, scale = (maxs-mins))
#Grabbing the maximum and minimum values of the dataframe
maxs <- apply(df_overall.scores.2018, 2, max)
mins <- apply(df_overall.scores.2018, 2, min)
maxs - mins
maxs
mins
maxs - mins
#Normalizing the data
scaled_data <- scale(df_overall.scores.2018, center = mins, scale = as.numeric(maxs-mins))
maxs + mins
as.numeric(maxs - mins)
as.numeric(maxs)
as.numeric(mins)
rm(maxs, mins)
View(col.data)
View(col.data)
model <- lm(Score ~ ., train_2018)
print(summary(model))
#Train and build model
model <- lm(Score ~ ., train_2018)
#Using caTools for a lineair regression
library(caTools)
#setting seed
set.seed(101)
# split up the sample, splitting the data into a 80-20 trainingdata and testingdata
sample_2018 <- sample.split(df_overall.scores.2018$Score, SplitRatio = 0.8)
# 80% of my data will be for training purposes
train_2018 <- subset(df_overall.scores.2018, sample == TRUE)
# 20% of my data will be for testing purposes
test_2018 <- subset(df_overall.scores.2018, sample == FALSE)
#Train and build model
model <- lm(Score ~ ., train_2018)
print(summary(model))
#Train and build model
model <- lm(Score ~ ., train_2018)
# split up the sample, splitting the data into a 80-20 trainingdata and testingdata
sample_2018 <- sample.split(df_overall.scores.2018$Score, SplitRatio = 0.8)
# 80% of my data will be for training purposes
train_2018 <- subset(df_overall.scores.2018, sample == TRUE)
# 20% of my data will be for testing purposes
test_2018 <- subset(df_overall.scores.2018, sample == FALSE)
library(dplyr)
# 80% of my data will be for training purposes
train_2018 <- subset(df_overall.scores.2018, sample == TRUE)
# split up the sample, splitting the data into a 80-20 trainingdata and testingdata
sample_2018 <- sample.split(df_overall.scores.2018$Score, SplitRatio = 0.8)
# 80% of my data will be for training purposes
train_2018 <- subset(df_overall.scores.2018, sample == TRUE)
#--------------------------------------------------------------------------------------------#
#2018 - Machine learning
#Figuring out which columns has a correlation with each other
#Variable created which only subtracts the numeric values(columns) of the dataset
num.cols <- sapply(df_overall.scores.2018, is.numeric)
#Filtering the data
col.data <- cor(df_overall.scores.2018[,num.cols])
#Using caTools for a lineair regression
library(caTools)
#setting seed
set.seed(101)
# split up the sample, splitting the data into a 80-20 trainingdata and testingdata
sample_2018 <- sample.split(df_overall.scores.2018$Score, SplitRatio = 0.8)
# 80% of my data will be for training purposes
train_2018 <- subset(df_overall.scores.2018, sample == TRUE)
# 20% of my data will be for testing purposes
test_2018 <- subset(df_overall.scores.2018, sample == FALSE)
# 80% of my data will be for training purposes
train_2018 <- subset(df_overall.scores.2018, sample == T)
# 80% of my data will be for training purposes
train_2018 <- subset(df_overall.scores.2018, sample_2018 == TRUE)
# 20% of my data will be for testing purposes
test_2018 <- subset(df_overall.scores.2018, sample_2018 == F)
#Train and build model
model <- lm(Score ~ ., train_2018)
print(summary(model))
set.seed(101)
# split up the sample, splitting the data into a 80-20 trainingdata and testingdata
sample_2018 <- sample.split(df_overall.scores.2018$Overall.scores, SplitRatio = 0.8)
# 80% of my data will be for training purposes
train_2018 <- subset(df_overall.scores.2018, sample_2018 == TRUE)
# 20% of my data will be for testing purposes
test_2018 <- subset(df_overall.scores.2018, sample_2018 == F)
#Train and build model
model <- lm(Score ~ ., train_2018)
print(summary(model))
sample_2018 <- sample.split(df_overall.scores.2018$GDP.per.capita, SplitRatio = 0.8)
# 80% of my data will be for training purposes
train_2018 <- subset(df_overall.scores.2018, sample_2018 == TRUE)
# 20% of my data will be for testing purposes
test_2018 <- subset(df_overall.scores.2018, sample_2018 == F)
#Train and build model
model <- lm(Score ~ ., train_2018)
print(summary(model))
# split up the sample, splitting the data into a 80-20 trainingdata and testingdata
sample_2018 <- sample.split(df_overall.scores.2018$Social.support, SplitRatio = 0.8)
print(summary(model))
set.seed(101)
# split up the sample, splitting the data into a 80-20 trainingdata and testingdata
sample_2018 <- sample.split(df_overall.scores.2018$Social.support, SplitRatio = 0.8)
# 80% of my data will be for training purposes
train_2018 <- subset(df_overall.scores.2018, sample_2018 == TRUE)
# 20% of my data will be for testing purposes
test_2018 <- subset(df_overall.scores.2018, sample_2018 == F)
#Train and build model
model <- lm(Social.support ~ ., train_2018)
print(summary(model))
#Using caTools for a lineair regression
library(caTools)
#setting seed
set.seed(101)
# split up the sample, splitting the data into a 80-20 trainingdata and testingdata
sample_2018 <- sample.split(df_overall.scores.2018$Overall.scores, SplitRatio = 0.8)
# 80% of my data will be for training purposes
train_2018 <- subset(df_overall.scores.2018, sample_2018 == TRUE)
# 20% of my data will be for testing purposes
test_2018 <- subset(df_overall.scores.2018, sample_2018 == F)
#Train and build model
model <- lm(Overall.scores ~ 4:9, train_2018)
print(summary(model))
#Train and build model
model <- lm(Overall.scores ~ 4:9, train_2018)
#Using caTools for a lineair regression
library(caTools)
#setting seed
set.seed(101)
# split up the sample, splitting the data into a 80-20 trainingdata and testingdata
sample_2018 <- sample.split(df_overall.scores.2018$Overall.scores, SplitRatio = 0.8)
# 80% of my data will be for training purposes
train_2018 <- subset(df_overall.scores.2018, sample_2018 == TRUE)
# 20% of my data will be for testing purposes
test_2018 <- subset(df_overall.scores.2018, sample_2018 == F)
#Train and build model
model <- lm(Overall.scores ~ Score + GDP.per.capita + Social.support + Healthy.life.expectancy + Generosity - Perceptions.of.corruption, train_2018)
print(summary(model))
#Train and build model
model <- lm(Overall.scores ~ Score + GDP.per.capita + Social.support + Freedom.to.make.life.choices + Healthy.life.expectancy + Generosity - Perceptions.of.corruption, train_2018)
print(summary(model))
res <- residuals(model)
res <- as.data.frame(res)
head(res)
ggplot(res, aes(res)) + geom_histogram(fill="Blue")
library(ggplot2)
ggplot(res, aes(res)) + geom_histogram(fill="Blue")
rm(res)
View(model)
res <- residuals(model)
res <- as.data.frame(res)
head(res)
library(ggplot2)
ggplot(res, aes(res)) + geom_histogram(fill="Blue")
plot(model)
rm(res)
plot(model)
result <- cbind(overall_scores_predictions, test_2018$Overall.scores)
colnames(results) <- c("Predicted", "Actual")
results <- as.data.frame(results)
print(head(results))
result <- cbind(overall_scores_predictions, test_2018$Overall.scores)
colnames(result) <- c("Predicted", "Actual")
result <- as.data.frame(result)
print(head(result))
#Predictions
overall_scores_predictions <- predict(model, test_2018)
#Grabbing the root mean squared errors
result <- cbind(overall_scores_predictions, test_2018$Overall.scores)
colnames(result) <- c("Predicted", "Actual")
result <- as.data.frame(result)
print(head(result))
min(result)
max(result)
#Grabbing the root mean squared errors, to see how off i'm are
mse <- mean((result$Actual - results$Predicted)^2)
mse <- mean((result$Actual - result$Predicted)^2)
print(mse)
rmse <- (mse^0.5)
print(rmse)
mse <- mean((result$Actual - result$Predicted)^2)
print(mse)
rmse <- (mse^0.5)
print(rmse)
#Sum of the squared errors
SSE <- sum((result$Predicted - result$Actual)^2)
SST <- sum((mean(df_overall.scores.2018$Overall.scores) - result$Actual)^2)
R2 <- 1 - SSE/SST
print(R2)
#Train and building the model
model <- lm(Overall.scores ~ Score + GDP.per.capita + Social.support + Freedom.to.make.life.choices + Healthy.life.expectancy + Generosity - Perceptions.of.corruption, train_2018)
#plot(model) #for more info (plots) about the residuals
print(model)
#Figuring out which columns has a correlation with each other
#Variable created which only subtracts the numeric values(columns) of the dataset
num.cols <- sapply(df_overall.scores.2018, is.numeric)
#Filtering the data
col.data <- cor(df_overall.scores.2018[,num.cols])
print(col.data)
print(result)
print(mse)
rm(rmse)
rm(SSE, SST)
rm(R2)
source('C:/Users/Jawad/Desktop/School/R/R-project/UdemyCourse/Datasets/Happinnes.R')
install.packages(c("caTools", "dplyr", "ggplot2", "ggthemes"))
source('C:/Users/Jawad/Desktop/School/R/R-project/UdemyCourse/Datasets/Happinnes.R')
View(pl_barplot_2018)
View(pl_barplot_2018)
View(pl_corruption_2018)
View(pl_histrogram_2018)
pl_barplot_2019 + geom_bin2d() + scale_fill_gradient(high = "red", low = "green")
#Created a histrogram which outputs the scores of the dataset
pl_histrogram_2019 <- ggplot(data = df_overall.scores.2019, aes(x=Score))
print(pl_histrogram_2019 + geom_histogram(binwidth = 0.1, color="Red", fill="Pink", alpha=0.4))
pl_2018 + geom_point(alpha=0.6, aes(size=Perceptions.of.corruption, color=Perceptions.of.corruption)) + scale_color_gradient(low="Blue", high = "Red")
